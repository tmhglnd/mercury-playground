{
  "-tutorials": "// Welcome to the Mercury Playground ^^\n// click \"play\" to start the code\n// adjust the code below:\n\nlist kickBeat [1 0.01 0.1 1 0]\nnew sample kick_house time(1/16) play(kickBeat)\n\nlist hatBeat euclid(16 7)\nnew sample hat_909 time(1/16) play(hatBeat) pan(0.5)\n\nnew sample snare_hvy time(1 3/4)\n\nlist positions sineFloat(16 6.523 0 0.6)\nlist pitch repeat([2 1 1 0.84 0.94] 16)\nnew sample chimes_l time(1/16) shape(1 70 5) name(stut)\n\tset stut offset(positions) pan(random) gain(1) speed(pitch)\n",
  "000-intro": "// === TUTORIAL 000: Intro ===\n// Welcome to the Mercury tutorials!\n// These short tutorials will teach you everything \n// about the Mercury live coding language\n\n// Lines starting with '//' are comments and are not part of the code\n// (un)comment lines with Option+/ (or by backspacing the //)\n\n// Uncomment the line below and click 'play' above\n// to hear the harp sample play\n// new sample harp_up time(1)\n",
  "101-sample": "// === TUTORIAL 101: Sample ===\n// You can play a soundfile with 'new sample' \n// followed by the samplename, for example: kick_909\n// Start the code with 'play' or Alt + Enter\n// Stop the sound with 'silence' or Alt + .\n\nnew sample kick_909\n// Try some other sounds like: hat_909, chimes, kalimba_e\n// You can find all the sounds by clicking the menu 'sounds'\n// When you select a sound from the menu it is pasted on the \n// location of the cursor in the editor",
  "102-time": "// === TUTORIAL 102: Time ===\n// A sound is played once per bar by default.\n// You can change how often a sound is played in one measure/bar.\n// For example 1/4 means 1 bar divided by 4, so 4 times per measure.\n// 1/16 means 16 times per measure, etc.\n\nnew sample kick_909 time(1/4)\n// Try for example: 1/8, 3/16, 1/6, 5/32",
  "103-sounds": "// === TUTORIAL 103: Sounds ===\n// Code multiple sounds simply by creating extra lines \n// starting with 'new sample', followed by a sound name\n\nnew sample kick_909 time(3/8)\nnew sample hat_909 time(1/8)\nnew sample snare_909 time(1/2)\n\n// Try various time() arguments and add extra sounds",
  "104-tempo": "// === TUTORIAL 104: Tempo ===\n// We can change the tempo and other settings\n// with the 'set' keyword\n\nset tempo 115\n\nnew sample kick_808_dist time(3/8)\nnew sample hat_808 time(1/16)\nnew sample snare_808 time(1/2)\n\n// Some genres are defined by there own bpm range\n// Try for example tempo 86 for HipHop, \n// or 162 for Drum'n'Bass",
  "105-offset": "// === TUTORIAL 105: Offset ===\n// We can keep the time interval the same, but play \n// sounds at a different position in the bar by \n// using a second argument for the offset\n\nnew sample kalimba_g time(1)\nnew sample kalimba_a time(1 3/16)\nnew sample kalimba_e time(1 3/8)\n\n// These sounds all play 1 time per measure\n// one starts at offset 0, one at 3/16 and one at 3/8\n// Try different offsets like 1/16, 3/4, 1/32",
  "106-rhythm": "// === TUTORIAL 106: Rhythm ===\n// With a list we can make more complex patterns, like a beat of 1's and 0's\n// A list is a collection of numbers (or words) written between \n// square-brackets \"[]\" and seperated by spaces\n// The list has a unique name that can be used in other functions\n\nlist hatBeat [1 0 1 0 0 1 0 1]\nnew sample hat_808 time(1/16) play(hatBeat)\n\n// 1 means play the sounds, a 0 means skip it\n// Try changing the values and length of the list \n// For example: [1 0 1 1 0]",
  "107-beat": "// === TUTORIAL 107: Beat ===\n// We can create multiple rhythms for different instruments \n// with lists of various lengths to create an interesting beat\n// Here the rhythm of the hihat is 7 long, and the tabla 5\n\nlist hatBeat [1 0 1 0 0 1 0]\nnew sample hat_909 time(1/16) play(hatBeat)\n\nlist tablaBeat [1 0 1 1 0]\nnew sample tabla_mid time(1/16) play(tablaBeat)\n\n// Try different rhythms combined with different times",
  "108-linear": "// === TUTORIAL 108: Linear ===\n// We can also create a list of sound names instead\n// to let one sample play the files sequentially\n\nlist drumSounds [kick_909 hat_909 snare_909 hat_909]\nnew sample drumSounds time(1/8)\n\n// Try adding or removing some sound names\n// For example add tabla_mid to the list\n// Find other sounds in the drop-down menu below",
  "109-linear-beat": "// === TUTORIAL 109: Linear Beat ===\n// We can now combine a list of sounds with a list of beats\n// and add an extra sample 1/4th of the time to make a steady beat\n\nset tempo 114\n\nlist sounds [hat_909 snare_909 hat_909 tabla_mid tabla_hi]\nlist beat [1 0 1 0 1 1]\nnew sample sounds time(1/16) play(beat)\n\nnew sample kick_909 time(1/4)\n\n// It gradually becomes more complex and interesting\n// Try different combinations of beats, sounds and time",
  "110-polyrhythm": "// === TUTORIAL 110 Polyrhythm ===\n// We can also create a so called polyrhythm with time()\n// A polyrhythm is a composite rhythm of different timing\n// intervals within a measure\n\nnew sample kalimba_e time(1)\nnew sample kalimba_g time(1/3)\nnew sample kalimba_cis time(1/2)\nnew sample kalimba_a time(1/4)\n\n// Try changing some of the time values to play with the polyrhythm",
  "111-chance": "// === TUTORIAL 111: Chance ===\n// Instead of a 1 (100%) or 0 (0%) in the play method, \n// we can also use a decimal-point value that represents\n// a percentage of chance that the sound will play\n\nset tempo 115\n\nnew sample hat_808 time(1/16) play(0.6)\n// play hat 60% of the time\n\nnew sample kick_808_dist time(1/8) play(0.3)\n// play kick 30% of the time\n\nnew sample snare_808 time(1/2)\n// by default the sound is played 100% of the time\n\n// Try some different percentages with values between 0 and 1",
  "112-chance-list": "// === TUTORIAL 112: Chance List ===\n// It is also possible to add these chances in a list\n// This helps to create more complex rhythms with small variations\n\nlist hatBeat [1 0.1 0.9 0.2]\nnew sample hat_909 time(1/16) play(hatBeat)\n// plays 100%, 10%, 90% and 20% in a sequence\n\nlist kickBeat [1 0.05]\nnew sample kick_909 time(1/4) play(kickBeat)\n// plays 90% and then 5% of the time\n\nnew sample clap_909 time(1 7/8)\n\n// Try to make other lists of probabilities",
  "113-speed": "// === TUTORIAL 113: Speed ===\n// With the playback speed you do not affect the tempo, \n// but instead the pitch of the sound (higher or lower)\n// You can use this to create melodic like patterns\n\nlist pitch [1 0.5 0.25 1 2]\nnew sample pluck_a time(1/8) speed(pitch)\n\n// Try some different values like 0.3, 1.8, 3.14, 11.16",
  "114-soundscape": "// === TUTORIAL 114: Soundscape ===\n// We can combine multiple sounds with different \n// speeds to create a kind of soundscape\n\nnew sample gong_hi time(4) speed(0.3)\nnew sample bowl_hi time(3) speed(0.125)\nnew sample drone_cymbal time(7) speed(0.25)\n\n// Experiment with different time and speed values\n// You can use lists for the speed to even more create variations",
  "115-shape": "// === TUTORIAL 115: Shape ===\n// Some samples sound quite long. We can make longer samples \n// shorter with the shape() method, setting a fade-in \n// and fade-out time in milliseconds\n\nnew sample harp_down time(1/3) shape(1 100)\nnew sample bowl_hi time(1) shape(1000 2)\n\n// Try some different settings to hear the difference",
  "116-shape-list": "// === TUTORIAL 116: Shape List ===\n// We can also use a list to change the length of fade-in \n// and fade-out sequentially\n\nlist fadeIn [2 2 500]\nlist fadeOut [20 20 100 20 500]\nnew sample harp_down time(1/4) shape(fadeIn fadeOut)\n\n// Try some different values in the lists",
  "117-position": "// === TUTORIAL 117: Start Position ===\n// For longer samples it can be useful to start the playback \n// of the sound at a different position within the sample\n// You can do that with the start() function by giving a \n// value between 0 and 1 (0.5 is halfway through the sound)\n\nlist positions [0.7 0.2 0.3 0.2 0.5 0.1]\nnew sample choir_01 time(1/8) start(positions) shape(1 100 1)\n\n// The list contains different starting positions in % of \n// the length of the sound",
  "118-panning": "// === TUTORIAL 118: Panning ===\n// We can make the composition sound more interesting by using the \n// stereo field from our speakers (called panning).\n// We can place a sound left with -1, right with 1 and center with 0\n\nnew sample violin_c time(1) pan(-1)\nnew sample pluck_e time(1 3/16) pan(1)\nnew sample bamboo_g time(1 4/16) pan(0)\n\n// Try some different values for the panning between -1 and 1",
  "119-panning-list": "// === TUTORIAL 119: Panning List ===\n// Is with many functions we've seen so far we can also \n// use a list for the panning. Or use the argument 'random' \n// to randomize the panning\n\nlist panning [-1 -0.75 -0.5 -0.25 0 0.25 0.5 0.75 1]\nnew sample hat_808 time(1/16) pan(panning)\n// this sound will move from left to right\n\nnew sample tabla_mid time(1/4) pan(random)\n// this sound will play at a random position in the stereofield",
  "120-volume": "// === TUTORIAL 20: Volume ===\n// Sometimes you want some sounds to sound louder or softer \n// than others. For this we can use the gain() method. \n// A gain of 0 is off, a gain of 1 is the original volume \n// of the soundfile, a gain of 2 is 2x louder (be careful!).\n\nnew sample wood_hit gain(0.8) pan(-1)\nnew sample scrape gain(0.6)\nnew sample wood_plate gain(0.7) pan(1)\n\n// Try some different values for the gain but be careful with\n// values above 1!",
  "121-volume-list": "// === TUTORIAL 21: Volume List ===\n// With a volume list we can change the volume over time\n// to create more dynamics in the sound and make it more \"human\"\n\nlist dynamics [0.1 0.4 0.9 0.3 0.15 0.8 0.7 0.1]\nlist sounds [tabla_hi tabla_hi_short tabla_mid]\nnew sample sounds time(1/16) gain(dynamics)\n\n// Try some different list values",
  "122-time-divide": "// === TUTORIAL 122: Time Divide ===\n// The timediv() method allows you to subdivide the timing \n// into smaller portions based on a list of integer numbers\n// The values from other lists are still inremented as they\n// would when regularly playing the instrument\n\nset tempo 110\n\nnew sample hat_808 time(1/8) timediv([1 1 2 1 3 1 4 1])\nnew sample [kick_808_dist snare_808] time(1/2) timediv([1 1 1 4]) play([1 1 0 0 0 1 1])\n\n// Try some different list values",
  "123-humanize": "// === TUTORIAL 122: Humanize ===\n// Humanize the playback of an instrument with the human()\n// method. The argument is a delay range in milliseconds with\n// which the trigger of the sound is randomly delayed or rushed\n\nset tempo 110\n\nnew sample hat_808 time(1/16) human(10)\nnew sample [kick_808_dist snare_808] time(1/2) human(100)\n\n// Try some different list values",
  "124-note-&-tune": "// === TUTORIAL 124: Note & Tune ===\n// It is also possible to change the pitch of a sample with the \n// note() function, similar to the note function in a synth \n// (see tutorial 203). In the case the sample is not recorded at \n// c4 (midi 60, 261.626Hz) you'll have to set the tune() in order \n// to get the correct pitch transposition. Any adjustments to speed() \n// will also affect the audible pitch together with note().\n\nset scale dorian eb\nset tempo 100\n\nnew sample kalimba_a time(1/4) note([0 7 5 3] 2) tune(a3)\nnew sample piano_e time(1/4 1/8) note([0 9 12 10 7 3] 1) tune(e3)\n\n// Try other samples to hear the melody and adjust the tune accordingly",
  "125-name-instruments": "// === TUTORIAL 125: Name Instruments ===\n// Instruments can have a name. Giving the instrument a name gives two advantages:\n// 1. Parameters can be set for the instrument on another line with `set <name>`\n// 2. Re-evaluating code will transfer the current count to the new instrument.\n//    This will preserve continuity while sequencing (long) lists, instead\n//    of hearing the counter reset every time code is evaluated\n\nset tempo 100\nset scale minor\n\nlist notes spread(13 0 24)\nlist rhythm euclid(16 13)\nnew synth saw note(notes 0) time(1/16) play(rhythm) name(synthy)\n\n// these parameters are send to the synth named \"synthy\"\nset synthy fx(filter low 3000 0.3) fx(degrade 0.4) fx(delay)\n\n// try evaluating the code multiple times to hear the pattern does not reset",
  "201-synth": "// === TUTORIAL 201: Synth ===\n// Instead of playing samples we can also create a synthesizer\n// (synth) with 'new synth' that generates a sound based on \n// various types of waveforms\n\nnew synth saw\n// new synth sine\n// new synth square\n// new synth triangle\n\n// Try these different types of synths by (un)commenting",
  "202-synth-time": "// === TUTORIAL 202: Synth Time ===\n// Many of the functions from the 'sample' can also be \n// applied to the synth, for example with the time()\n// we can choose the time interval it is triggered at\n\nnew synth saw time(1/8)\n\n// Try also: play(), gain(), pan() combined with lists\n// See tutorials 106, 107, 110, 111, 112, 118, 120",
  "203-note": "// === TUTORIAL 203: Note ===\n// To choose a note to play for the synth we use the note() \n// function. This function expects a number as a semitone (half-step)\n// on the piano-keyboard. The numbers can be positive or negative.\n\nnew synth saw time(1) note(0)\nnew synth saw time(1 1/16) note(3)\nnew synth saw time(1 3/16) note(7)\n\n// Try different note numbers like: -5, 12, 3.14",
  "204-melody": "// === TUTORIAL 204: Melody ===\n// Similar to how we create a list for a rhythm we can\n// also create a list of notes to create a melody\n\nset tempo 137\n\nlist melody [0 7 12 19 15 12 5 3 7 5 2]\nnew synth saw time(1/16) note(melody)\n\n// Try some different values for the list to create \n// other melodies",
  "205-octave": "// === TUTORIAL 205: Octave ===\n// With a second argument in the note() function we can choose\n// an octave offset. Stepping up one octave is the same as\n// adding 12 to the semitone.\n\nset tempo 137\n\nlist theMelody [0 7 5 3 7 5 2]\nlist theOctaves [0 0 0 1 1 1 2 2 2]\nnew synth saw time(1/16) note(theMelody theOctaves)\n\n// Here the octave is changed every 3 notes",
  "206-scales": "// === TUTORIAL 206: Scales ===\n// In many styles of music it is common to not use all the\n// notes that are available to us (like all the keys on the piano)\n// But instead use a subset of those notes. This is called a scale.\n// The scale usually gives a certain feeling to the sound.\n// For example major=happy and minor=sad (oversimplification)\n\nset tempo 115\nset scale major\n\nlist melody [0 1 2 3 4 5 6 7 8 9 10 11 12]\nnew synth saw time(1/16) note(melody 2)\n\n// Try changing the scale from major to minor and hear the difference\n// You hear some notes twice, because some values between 0-12 \n// don't fit in the scale, so they're shifted to the closest value\n// that does belong to the scale",
  "207-more-scales": "// === TUTORIAL 207: More Scales ===\n// There are many scales to choose from. If you like to see the \n// complet entire list you can get it with scaleNames()\n// Then 'print' the list to the console\n\nlist scales scaleNames()\nprint scales\n\nset tempo 143\nset scale romanian_minor\n\nlist melody [12 11 10 9 8 7 6 5 4 3 2 1 0]\nnew synth square time(1/16) note(melody 1)\n\n// Try some names of the scales you see in the console",
  "208-root": "// === TUTORIAL 208: Root ===\n// A scale starts at a specified note. This note is the root.\n// By default this root is a 'c', but you can choose other roots\n// like d, f#, gb etc. \n\nset tempo 97\nset scale minor_pentatonic gb\n\nlist melody [12 11 10 9 8 7 6 5 4 3 2 1 0]\nnew synth square time(1/16) note(melody 1)\n\n// Try some of the different roots to hear the difference",
  "209-synth-shape": "// === TUTORIAL 209: Synth Shape ===\n// The shape() method for the synth allows us to create a longer\n// or shorter sound with a fade-in/fade-out. We can also set \n// the shape(off) resulting in a never stopping sound.\n\nnew synth triangle time(1/4) shape(1 1/16) note(0 2)\nnew synth triangle time(1) shape(off)\nnew synth triangle time(1/2) shape(1/4 10) note(0 1)",
  "210-synth-shape-list": "// === TUTORIAL 210: Synth Shape List ===\n// And as you might have expected by now we can also use a \n// list to modulate the length from the fade-in and fade-out times\n\nlist fadeOut [20 20 100 20 200 500]\nnew synth saw time(1/16) shape(2 fadeOut)\n// here the synth has an attack of 2 ms and a release depending on the list",
  "211-super-synth": "// === TUTORIAL 211: Super Synth ===\n// The super synth is a synth that uses multiple\n// waveforms at the same time with a small detuning to \n// create a more richer sound\n\nnew synth saw time(1/16) super(3 0.142) shape(1 80 1)\n\n// Try different amounts of voices: 3, 5, 11\n// Try different detunings: 1.021, 7.245, 12.032",
  "212-filter": "// === TUTORIAL 212: Filter ===\n// The sound of the synth is still very bright. Most synths \n// therefore use a filter to change the color of the sound. \n// This can be done with the `fx(filter)`, the `fx()` is an \n// effect function that allows us to change the sound in \n// various ways. Read more about FX in chapter 3.\n\nnew synth saw time(1/16) fx(filter low 1200 0.6) shape(1 100)\n// This filter removes high frequencies above 1200Hz (lowpass)\n// And has a little resonance on the cutoff frequency\n// Resonance results in a whistling sounding effect\n// Try changing the 1200 to other values between 100-16000\n// and the 0.6 to other values between 0.1 and 0.9",
  "213-filter-modulation-1": "// === TUTORIAL 213: Filter Modulation ===\n// We can modulate the cutoff frequency and the resonance\n// of the filter with values from two different lists\n// Make sure the cutoffs are values between 50 and 18000 (Hz)\n// and the resonance are values between 0 and 1\n\nlist cutoffs [200 400 700 1000]\nlist qs [0.3 0.3 0.3 0.3 0.8]\n\nnew synth saw time(1/16) fx(filter low cutoffs qs) shape(1 80)\n\n// Try some different values for both",
  "213-filter-modulation-2": "// === TUTORIAL 213: Filter Modulation 2 ===\n// We can make even more interesting filter modulations by adding\n// a few extra arguments to the filter fx function.\n// When doing that we can choose a low and high frequency range\n// between which a sinewave, sawtooth up or sawtooth down can modulate\n// The modulation time is designed by the division argument\n\nlist nts spread(5 0 12)\nnew synth saw time(1/2) note(nts) shape(off) fx(filter low 1/1 100 4000 0.8)\n// this filter modulates up and down once per bar between 100 and 4000 Hz with resonance 0.8\n\nnew synth saw time(1/16) note(nts 1) shape(off) fx(filter low 1/16 200 6000 0.6 0 0.05)\n// this filter modulates down every 1/16 note from 6000 to 200 Hz with resonance of 0.6\n// the 0.2 determins the slope curve the filter goes up/down with (try 0.05 and 1 to hear the difference)\n\n// arguments:\n// fx(filter <type> <division> <low> <high> <resonance> <direction> <slope-curve>)",
  "214-note-slide": "// === TUTORIAL 214: Note Slide ===\n// With the 'slide()' function we can slide the pitch \n// from one note to another (called portamento) in a specified\n// amount of time (division or milliseconds)\n\nset tempo 123\nset scale minor b\n\nlist bassLine repeat([3 2 0 -7] 4)\nnew synth saw note(bassLine 0) shape(2 250) time(1/4) slide(1/8)\n\n// Try some different values for both",
  "220-polyphonic-synth": "// === TUTORIAL 220: polySynth ===\n// The polySynth is a polyphonic synthesizer, this allows you\n// to play overlapping notes or notes at the same time to generate\n// chord progressions\n\nset tempo 80\nset scale major c\n\n// a 2-dimensional list of notes plays all the notes at the same time\nlist chord [ [0 4 5 7 8 10 12] ]\nnew polySynth sine note(chord 2) time(1/2) shape(1 1/4) \n\n// Try some different values for to generate more chords",
  "221-chord-progression": "// === TUTORIAL 221: Chord Progression ===\n// With the chordsFromNumerals function you can generate a\n// 2-dimensional list containing the notes for the chords you specify\n// Chords are numbered I to VII. Adding an 'm' makes them minor\n// It is also possible to add the 7, 9, 11 or 13th\n\nset tempo 100\n// we can set the scale to none to allow all the notes to be played\nset scale none\n\n// a chord progression in the style of the 4-chord-song\nlist progression chordsFromNumerals([I IV V VIm])\n// see in the console that the result is a 2d-list\nprint progression\n\nnew polySynth sine note(progression 2) time(1/1) shape(1 3/4 1/4) \n\n// Try some different numerals to hear how the chords change",
  "222-overlapping-notes": "// === TUTORIAL 222: Overlapping Notes ===\n// We can also generate a list of notes for an arpeggiator and\n// let the notes overlap by creating a longer length than \n// the space in between the notes\n\nset tempo 110\nset scale none\n\n// here the chord progression is repeated 4 times and flattened into a 1d list\nlist progression flat(repeat(chordsFromNumerals([I IV V VIm]) 4))\nprint progression\n\n// hear how some of the notes are not played when we turn voice stealing off.\n// You can change this by setting voice-stealing to 'on', this is the default\nnew polySynth sine note(progression 2) time(1/12) shape(1 1/1) steal(off)\n",
  "223-polyphonic-sample": "// === TUTORIAL 223: Polyphonic Sample ===\n// The polySample is a polyphonic sample player, allowing you to play\n// overlapping sounds and also play notes with those sounds.\n// \n\nset tempo 110\nset scale none\n\n// here the chord progression is repeated 4 times and flattened into a 1d list\nlist progression flat(repeat(chordsFromNumerals([I7 IV7 V7 VIm7]) 4))\nprint progression\n\n// With the sample it is important to have voice stealing 'on' when the shape is\n// turned off. Otherwise all the voices will stay busy because there is no \"fade-out\"\nnew polySample bamboo_g name(polySamp)\n    set polySamp note(progression 2) tune(67) time(1/16) shape(off) steal(on)\n",
  "301-fx-delay": "// === TUTORIAL 301: FX Delay ===\n// There are many different effects that can be added\n// to your sounds. The Delay effect creates echos of the\n// sound that slowly fade away in a rhythmic pattern\n\nset tempo 100\nnew sample piano_g time(2) fx(delay 3/16 2/16 0.8)\n\n// The delay can have arguments for the left/right delaytimes\n// in division. A decimal-point value 0-1 determines the amount of fade-out \n// Try different delaytimes: 5/16, 3/4, 1/32, 1/12\n// Try changing the values in the function to hear what happens\n// It is also possible to modulate the parameters with lists",
  "302-fx-distortion": "// === TUTORIAL 302: FX Distortion ===\n// With the distortion effect you can give the sound a crunchy\n// quality, like it is sounding through a guitar amplifier\n// fx(drive amount) - alias: distort\n\nset tempo 100\n\nlist amounts spread(5 10 50)\nnew loop amen time(1) gain(0.6) fx(drive amounts)\n\n// Try changing the values in the function to hear what happens\n// It is also possible to modulate the parameters with lists",
  "303-fx-reverb": "// === TUTORIAL 303: FX Reverb ===\n// With the reverb effect you can place the sound in a \n// small room or big church\n\nnew synth saw note(0 0) time(1) shape(1 1/4 1) fx(reverb 0.3 10)\nnew synth saw note([0 3 7] 1) time(1/4) shape(1 1/32) fx(reverb 0.5 3)\n\n// The first decimal value determines the balance between original (dry)\n// and reverb sound (wet). The second argument is the reverb time in \n// seconds\n// Try changing the values in the function to hear what happens\n// It is also possible to modulate the parameters with lists",
  "304-fx-shift": "// === TUTORIAL 304: Pitch Shift ===\n// With the pitch shifter effect you can change the pitch\n// of a sound in semitones. Allowing you to make melodies with \n// a single sample\n\nset scale harmonic_minor c\nnew sample chimes time(1/8) fx(shift [0 3 2 -1 7 5]) shape(100)\n\n// The first argument is the pitch shift in semitones which is\n// also mapped according to the scale that is set\n// Try changing the values in the function to hear what happens\n// It is also possible to modulate the parameters with lists",
  "305-fx-squash": "// === TUTORIAL 305: Squash ===\n// The squash effect is also a type of distortion effect that\n// compresses the sound a bit softer in the beginning but \n// with higher values introduces some crunch also\n// fx(squash amount)\n\nset tempo 115\n\nlist squashes [4 15 10 4 40]\nnew sample kick_909 time(1/16) fx(squash squashes) shape(1 50)\n\n// Try changing the values in the function to hear what happens\n// It is also possible to modulate the parameters with lists",
  "306-fx-set-all": "// === TUTORIAL 306: FX All ===\n// It is possible to give multiple sounds the same effects\n// by using the `set all` code\n\nnew sample kick_909 time(1/2)\nnew sample hat_909 time(1/4 1/8)\nnew synth saw time(3/16) note(0 1) shape(1 1/8) super(3 0.0423)\n\nset all fx(shift -12 0.5) fx(squash 70) fx(reverb 0.5 2)\n\n// Note that this actually creates individual effects for all the \n// sounds. Meaning they can all have individual modulation speeds\n// when using a list with arguments",
  "307-fx-filter-modulation": "// === TUTORIAL 307: FX Filter Modulation ===\n// We can make even more interesting filter modulations by adding\n// a few extra arguments to the filter fx function.\n// When doing that we can choose a low and high frequency range\n// between which a sinewave, sawtooth up or sawtooth down can modulate\n// The modulation time is designed by the division argument\n\nlist nts spread(5 0 12)\nnew synth saw time(1/2) note(nts) shape(off) fx(filter low 1/1 100 4000 0.8)\n// this filter modulates up and down once per bar between 100 and 4000 Hz with resonance 0.8\n\nnew synth saw time(1/16) note(nts 1) shape(off) fx(filter low 1/16 200 6000 0.6 0 0.05)\n// this filter modulates down every 1/16 note from 6000 to 200 Hz with resonance of 0.6\n// the 0.2 determins the slope curve the filter goes up/down with (try 0.05 and 1 to hear the difference)\n\n// arguments:\n// fx(filter <type> <division> <low> <high> <resonance> <direction> <slope-curve>)",
  "307-fx-filter": "// === TUTORIAL 307: FX Filter ===\n// The filter is a simple filter where the first argument sets the type of the \n// filter such as low(pass), band(pass) and hi(pass). The second argument sets \n// the cutoff frequency with a number or list. The third argument changes the \n// resonance (Q)\n\nnew synth saw shape(off) time(1/4) fx(filter low [8000 400 2000 200] [0.2 0.5 0.8])\n// Try changing the values in the function to hear what happens\n// It is also possible to modulate the parameters with lists\n\n// NOTE: cutoff ramptime in milliseconds is deprecated, now use modulation \n// filter or triggerFilter !!!",
  "308-fx-trigger-filter": "// === TUTORIAL 307: FX Trigger Filter ===\n// The trigger filter is a filter where the cutoff frequency is \n// driven by an envelope (shape). The filter is triggered every time\n// the note is played. \n// Set the filter type: lowpass, highpass or bandpass.\n// Set the attack and release times in milliseconds or relative to the tempo.\n// Set the high and low frequency points between which the envelope moves.\n\nnew synth saw note(0 0) time(1/1) shape(off) fx(triggerFilter low 1/4 3/4 5000 100)\n\n// Try changing the values in the function to hear what happens\n// It is also possible to modulate the parameters with lists",
  "309-fx-compress": "// === TUTORIAL 308: FX Compressor ===\n// A compressor allows you to reduce the dynamic range of a synth or sample.\n// The signals volume gets reduced by a specified ratio when it crosses \n// the threshold\n// Set the threshold in dBFS (-100 to 0, default = -30)\n// Set the compression ratio (20 to 0, default = 6)\n// Set the attack and release time in milliseconds or relative to tempo\n\nnew loop amen time(1) fx(compress -20 5 5 50)\n\n// Try changing the values in the fx function to hear what happens\n// It is also possible to modulate the parameters with lists",
  "310-fx-degrade": "// === TUTORIAL 310: FX Degrade ===\n// A Downsampling Chiptune effect. Downsamples the signal by a specified amount\n// Resulting in a lower samplerate, making it sound more like 8bit/chiptune\n// fx(degrade amount) - alias: chip\n\nlist degrades spreadF(16 0.5 0.9)\nnew sample choir_o time(1/4) shape(off) fx(degrade degrades)\n\n// Try changing the values in the fx function to hear what happens\n// It is also possible to modulate the parameters with lists",
  "311-fx-chorus": "// === TUTORIAL 311: FX Chorus / Double ===\n// A Chorus and Doubling effect. The Chorus creates 2 copies of the sound.\n// One on the left and one right. These copies slowly change in time creating\n// modulating effects that make the sound more wider.\n// Use the parameters modulation time (division), depth (ms) and wetdry (0-1)\nnew synth saw note(spread(5 0 12) 1) time(1/4) shape(1 1/2) fx(chorus 8/1 40 0.5) \n\n// The double effect does the same but removes the original from the center (wet = 1)\n// Giving the effect of hearing 2 instruments.\nnew sample snare_909 time(1/2 1/4) speed(0.6) fx(double)\n\n// Try changing the values in the fx function to hear what happens\n// It is also possible to modulate the parameters with lists",
  "400-algorithms": "// === TUTORIAL 400: Algorithmic Composition ===\n// This chapter discusses the algorithmic processes that can be used in \n// Mercury. Mercury is heavily inspired by the composition technique Serialism. \n// This technique approaches every musical parameter (rhythm, pitch, dynamics, \n// etc) as an individual sequence of numbers. These sequences can then be \n// transformed in many ways to extend and generate new musical material. \n\n// With algorithmic processes (functions) we can generate or transform lists. \n// With the lists we can control the parameters in functions of instruments. By \n// combining various list functions we can create more complex outputs.\n\n// This chapter will cover most of the algorithmic methods, but many unique \n// combinations are up to you to discover!\n\n// A list is a collection of items (numbers, words) that has a unique name\nlist myValues [1 2 3.14 6.18 kick_909 snare_808]\n\n// It is possible to print the content of a list. This is useful to view\n// the result of list functions\nprint myValues",
  "401-spread": "// === TUTORIAL 401: Spread ===\n// Generate a list of n-length containing whole numbers\n// Starting at x and ending at y (excluding y)\n// spread(size low high)\n\n// Useful for melodies and ascending/descending number\n// sequences for modulation of for example note-length\n\nlist melody spread(5 0 12)\nlist length spread(7 500 20)\nprint melody length\n\nnew synth saw note(melody 1) time(1/16) shape(1 length)",
  "402-spreadinclusive": "// === TUTORIAL 402: Spread Inclusive ===\n// Generate a list of n-length containing whole numbers\n// Starting at x and ending at y (including y)\n// spreadInclusive(size low high)\n\n// Useful for melodies and ascending/descending number\n// sequences for modulation of for example note-length\n\nlist melody spreadInclusive(5 0 12)\nlist length spreadInclusive(7 500 20)\nprint melody length\n\nnew synth saw note(melody 1) time(1/16) shape(1 length)",
  "403-spread-float": "// === TUTORIAL 403: Spread Float ===\n// Generate a list of n-length containing floating-point numbers\n// Starting at x and ending at y (excluding y)\n// spreadFloat(size low high) (alias: spreadF)\n// spreadInclusiveFloat(size low high) (alias: spreadInclusiveF)\n\n// Useful for parameters that are based on floating-point numbers\n// such as sequences for modulation of for example gain and panning\n\nlist volume spreadF(16 0 1)\nlist panning spreadInclusiveF(7 -1 1)\nprint volume panning\n\nnew synth saw note(0 1) time(1/16) shape(1 80) pan(panning) gain(volume)",
  "404-fill": "// === TUTORIAL 404: Fill ===\n// Fill a list with values and a number of repetitions. The values\n// are provided in pairs of number, amount. \n// fill(value1 amount1 value2 amount2 etc...)\n\n// Useful for creating longer lists with a lot of duplicate values\n\nlist melody fill(0 4 7 2 3 4 12 2 9 4 3 2 2 2)\nprint melody\n\nnew synth sine note(melody 2) time(1/16)",
  "405-euclidean-rhythm": "// === TUTORIAL 405: Euclidean Rhythm ===\n// Generate a euclidean rhythm. The algorithm evenly spaces n-beats over \n// n-steps, return a list of 1's and 0's. Inspired by Godfried Toussaints\n// famous paper \"The Euclidean Algorithm Generates Traditional Musical Rhythms\".\n// euclidean(steps, beats, rotate) (alias: euclid)\n\n// Useful for generating intricate rhythmical patterns with the play() function\n\nset tempo 130\nlist rhythm1 euclid(16 5)\nlist rhythm2 euclid(8 5)\nprint rhythm1 rhythm2\n\nnew sample bongo time(1/16) play(rhythm1)\nnew sample bongo_lo time(1/16) play(rhythm2) ",
  "406-hexadecimal-rhythm": "// === TUTORIAL 406: Hexadecimal Rhythm ===\n// Hexadecimal beats make use of hexadecimal values (0 - f) that are a base-16\n// number system. Because one digit in a base-16 number system has 16 possible\n// values (0 - 15) these can be converted to 4 bits that therefore can be seen \n// as groups of 4 16th notes. These hexadecimal values will then represent any \n// permutation of 1's and 0's in a 4 bit number, where 0 = 0 0 0 0, 7 = 0 1 1 \n// 1, b = 1 0 1 1, f = 1 1 1 1 and all possible values in between.\n\n// Useful for generating intricate rhythmical patterns with the play() function\n\nset tempo 130\nlist rhythm1 hex('f02c')\nlist rhythm2 hex('094a')\nprint rhythm1 rhythm2\n\nnew sample bongo time(1/16) play(rhythm1)\nnew sample bongo_lo time(1/16) play(rhythm2)",
  "407-fibonacci": "// === TUTORIAL 407: Fibonacci Numbers ===\n// Generate a list of Fibonacci numbers F[n] = F[n-1] + F[n-2]. The fibonacci \n// sequence is famous because it's numbers pop up in nature in many places \n// and when you divide any number in the sequence by its previous number it \n// converges towards the golden ratio (phi, 1.618)\n// fibonacci(amount)\n// fibonacci(amount, starting number)\n\n// Useful as a starting point for melodic content or modulation of parameters\n\nlist melody fibonacci(9)\nlist cutoff fibonacci(8 12)\nprint melody cutoff\n\nnew synth saw note(melody 1) time(1/8) shape(off) fx(filter cutoff)",
  "408-pisano-periods": "// === TUTORIAL 408: Pisano Periods ===\n// Generate Pisano periods from the Fibonacci sequence. The pisano period is a\n// result of applying a modulo (%) operation on the Fibonacci sequence \n// F[n] = (F[n-1] + F[n-2]) mod a. The length of the period differs per modulus\n// value, but the sequence will always repeat.\n\n// Useful as a starting point for melodic content or modulation of parameters\n\nlist melody pisano(13)\nprint melody\n\nnew synth sine note(melody 2) time(1/16)",
  "409-chord-lists": "// === TUTORIAL 442: Translate Time ===\n// Generate 2-dimensional arrays of relative notevalues that can \n// be used as chord information or flattened to generate melodic\n// progressions based on chords\n// chordsFromNumerals(list)\n\n// Convert a chord progression from roman numerals to semitones\n// alias: makeChords()\nprint chordsFromNumerals([I IIm IVsus2 V7 VIm9])\n\n// Convert a chord progression from chordnames to semitones\nprint chordsFromNames([C Dm Fsus2 G7 Am9])\n\nset scale chromatic c\nlist chords flatten(chordsFromNumerals(repeat([I7 IV7sus2 IIm7 V7] 2)))\nprint chords \n\nnew synth saw note(chords 1) time(1/16)",
  "410-random": "// === TUTORIAL 410: Random ===\n// Generate a list of n-length containing random values \n// of whole numbers between low and high value (excluding high)\n// Note that any time you evalute the code the random numbers are \n// different. See \"randomseed\" for a solution to this issue.\n// random(size low high)\n\n// Useful to generate random sequences for melodies and any parameter\n\nlist melody random(8 0 12)\nlist cutoff random(5 300 4000)\nlist length random(4 80 300)\nprint melody cutoff length\n\nnew synth saw note(melody 1) time(1/8) shape(1 length) fx(filter cutoff)",
  "411-random-seed": "// === TUTORIAL 411: Random Seed ===\n// Set the seed for the Random Number Generator (RNG). A value of 0 sets to \n// unpredictable seeding. Seeding the RNG results in predictable psuedo\n// random numbers that give the same result every time the code is\n// evaluated.\n// randomSeed anyValue\n\n// Useful to fix generated random numbers\n\n// Try both seeds and hear the difference\nset randomSeed 4738\n// set randomSeed 7385\n\nlist melody random(5 0 12)\nlist cutoff random(5 100 2000)\nlist rhythm random(16 0 2)\nprint melody cutoff rhythm\n\nnew synth saw note(melody 1) time(1/16) play(rhythm) fx(filter cutoff)",
  "412-drunk": "// === TUTORIAL 412: Drunk ===\n// Generate a list of n-length containing random values \n// of whole numbers between low and high value (excluding high)\n// Every random number is based on the previous number and generated\n// within a specified step-range.\n// drunk(size step low high)\n\n// Useful to generate random sequences for melodies and any parameter\n\nlist melody drunk(16 2 0 12)\nlist cutoff drunk(16 1000 300 4000)\nlist length drunk(16 50 80 500)\nprint melody cutoff length\n\nnew synth saw note(melody 1) time(1/16) shape(1 length) fx(filter cutoff)",
  "413-clave": "// === TUTORIAL 413: Clave ===\n// Generate random clave patterns. The output is a binary list that represents\n// a rhythm, where 1's represent onsets and 0's rests. A clave pattern can be\n// found in musical genres such as salsa, mambo, rumba, raggae, raggaeton and \n// more. It is usually defined as an alternation of a beat with 1 or 2 rests\n// clave(size)\n\n// Useful to generate random rhythms\n\nset tempo 130\nlist rhythm1 clave(8)\nlist rhythm2 clave(8)\nprint rhythm1 rhythm2\n\nnew sample bongo time(1/16) play(rhythm1)\nnew sample bongo_lo time(1/16) play(rhythm2)",
  "414-coin": "// === TUTORIAL 414: Coin ===\n// Generate a list of n-length containing random coin tosses \n// The resulting list only contains 0's and 1's\n// coin(size)\n\n// Useful to generate random rhythms\n\nset tempo 130\nlist rhythm1 coin(8)\nlist rhythm2 coin(8)\nprint rhythm1 rhythm2\n\nnew sample bongo time(1/16) play(rhythm1)\nnew sample bongo_lo time(1/16) play(rhythm2)",
  "415-choose": "// === TUTORIAL 415: Choose ===\n// Use Choose to randomly select items from a defined list\n// choose(size list)\n\n// Useful to generate random lists with predefined options\n// For example for melodies or sample selections\n\nlist melody choose(16 [-1 0 2 3 6 7])\nlist beat choose(8 [kick_808 hat_808 snare_808])\nprint melody beat\n\nnew synth sine note(melody 2) time(1/16)\nnew sample beat time(1/8)",
  "416-shuffle": "// === TUTORIAL 416: Shuffle ===\n// Shuffle the contents of a list. The shuffle order is also\n// controlled by the random seed.\n// shuffle(list) - alias: scramble\n\n// Useful to generate random orders of a predefined list\n// For example for melodies or sample selections\n\nlist melody shuffle([-1 0 2 3 6 7 9 12])\nlist beat shuffle([kick_808 hat_808 snare_808 tabla_hi_short])\nprint melody beat\n\nnew synth sine note(melody 2) time(1/16)\nnew sample beat time(1/8)",
  "420-reverse": "// === TUTORIAL 420: Reverse ===\n// Reverse the contents of a list.\n// reverse(list) - alias: rev\n\n// Useful to generate a reversed version of a list like\n// for example a melody\n\nlist melody [0 2 3 7 9 12]\nlist revMelody reverse(melody)\n\nnew synth saw note(melody 1) time(1/4)\nnew synth saw note(revMelody 2) time(1/4 1/8)",
  "421-palindrome": "// === TUTORIAL 421: Palindrome ===\n// Reverse the contents of a list and append it to \n// the original list to create a palindrome.\n// palinedrome(list) - alias: palin, mirror\n\n// Useful to extend a melody or list starting from a \n// single phrase\n\nlist melody palindrome([0 2 3 7 9 12])\nprint melody\n\nnew synth saw note(melody 1) time(1/16)",
  "422-invert": "// === TUTORIAL 422: Invert ===\n// Invert the contents of a list. This is done by looking at\n// the highest and lowest value in the list and flipping every\n// number to the opposite side.\n// invert(list) - alias: flip\n\n// Useful to transform a melodic phrase to generate new \n// musical material\n\nlist melody [0 3 2 7 9 7 12 14]\nlist inv invert(melody)\nprint melody inv\n\nnew synth saw note(melody 1) time(1/4)\nnew synth saw note(inv 0) time(1/4 1/8)",
  "423-join": "// === TUTORIAL 423: Join ===\n// Join to or more lists together into one longer list\n// join(list1 list2 ... list-n) - alias: combine\n\n// Useful to transform a melodic phrase to generate new \n// musical material\n\nlist melody [0 3 7 12]\nlist inv invert(melody)\nlist shuf shuffle(melody)\nlist joined join(melody inv shuf shuf)\nprint melody inv shuf joined\n\nnew synth sine note(joined 2) time(1/16)",
  "424-repeat": "// === TUTORIAL 424: Repeat ===\n// Repeat the content of a list a specified amount of times.\n// The amount can be specified as another list resulting in different\n// repetitions per value from the input list.\n// repeat(list amount)\n\nlist melody [0 3 7 12 9]\nlist repeats repeat(melody [4 2])\nprint melody repeats\n\nnew synth saw note(repeats 1) time(1/16)",
  "425-lace": "// === TUTORIAL 425: Lace ===\n// Interleave (lace/zip) the contents of two or more lists\n// The longest list is preserved but other lists are not repeated\n// in the interleaving process\n// lace(list1 list2 ... list-n) - alias: zip\n\nlist melody [0 3 7 9]\nlist melody2 add(melody 12)\nlist melody3 [24 27]\nlist laced lace(melody melody2 melody3)\nprint melody melody2 melody3 laced\n\nnew synth saw note(laced 1) time(1/16)",
  "426-lookup": "// === TUTORIAL 426: Lookup ===\n// Lookup any items from a list based on the numbers in another list.\n// The numbers represent the index (0-based) and wrap on the list length.\n// lookup(indeces items)\n\n// Useful to reorder content of a list\n\nlist sounds [kick_808 hat_808 snare_808]\nlist pattern [0 1 1 1 0 1 2 1]\nlist beat lookup(pattern sounds)\nprint beat\n\nnew sample beat time(1/16)",
  "427-clone": "// === TUTORIAL 427: Clone ===\n// Duplicate the contents of a list a specified amount of time\n// But add a value (offset) to every duplication based on the\n// the value in another list\n\n// Useful to generate melodic progressions\n\nset scale minor c\nlist notes [0 3 7 5]\nlist clones repeat(notes 4)\nlist melody clone(notes clones)\nprint notes clones melody\n\nnew synth sine note(melody 2) time(1/16)",
  "428-merge": "// === TUTORIAL 428: Merge ===\n// With the merge function you can combine multiple lists into\n// a 2-dimensional list. This can be useful when you want to generate\n// some chords for example.\n\nset scale minor d\n// different rows of notes are generated with various functions\nlist row1 spread(6 0 12) \nlist row2 cosine(6 3 7 19)\nlist row3 drunk(6 3 12 24)\n// the rows are merged into a 2d list and every item is repeated 4 times\nlist chords repeat(merge(row1 row2 row3) 4)\nprint chords\n\nnew polySynth saw note(chords 1) time(1/4) shape(1/6 100) fx(filter) fx(chorus)",
  "430-add-sub-div-mul": "// === TUTORIAL 430: Add ===\n// It is possible to perform basic arithmetic on entire\n// lists with a single scalare, or adding 2 lists together.\n// add(list1 list2/scalar) sub() div() mul() - alias: subtract, divide, multiply\n\nlist melody [0 3 7 3 5 7 9]\nlist melody2 add(melody 12)\nprint melody melody2\n\nnew synth saw note(melody) time(1/4)\nnew synth saw note(melody2) time(1/4 1/8)",
  "431-normalize": "// === TUTORIAL 431: Normalize ===\n// Normalize the content of a list. When normalizing a list \n// the lowest value will become 0 and the highest value 1.\n// All the values in between will be scaled in ratio to the \n// lowest and highest value.\n// normalize(list) - alias: norm()\n\nlist psn pisano(7)\nlist psnNorm normalize(psn)\nprint pattern psnNorm\n\nnew sample hat_808 time(1/16) gain(psnNorm)",
  "440-translate-notes": "// === TUTORIAL 440: Translate Notes ===\n// You can use various methods to translate between different\n// note notation formats such as Midi, Notenames and Frequency\n\n// Convert Array or Int as midi-number to midi-notenames (alias: mton)\nprint midiToNote([60 63 67 69 57 65])\n\n// Convert midi-pitches to frequency (A4 = 440 Hz) (alias: mtof)\nprint midiToFreq([60 63 67 69 57 65])\n\n// Convert Array of String as midi-notenames to midi-pitch (alias: ntom)\nprint noteToMidi(['c4' 'eb4' 'g4' 'a4' 'a3' 'f4'])\n\n// Convert midi-notenames to frequency (A4 = 440 Hz) (alias: ntof)\nprint noteToFreq(['c4' 'eb4' 'g4' 'a4' 'a3' 'f4'])\n\n// Convert frequency to nearest midi note (alias: ftom)\nprint freqToMidi([261 311 391 440 220 349])\n\n// Set detune flag to true to get floating midi output for pitchbend\nprint freqToMidi([261 311 391 440 220 349] true)\n\n// Convert frequency to nearest midi note name (alias: fton)\nprint freqToNote([261 311 391 440 220 349])",
  "441-translate-relative": "// === TUTORIAL 441: Translate Relative ===\n// You can use translate relative values/names to midi numbers or \n// frequencies easily with the relative and chroma methods \n\n// Convert relative semitone values to midi-numbers (alias: rtom)\n// specify the octave as second argument (default = 'C4' = 4 => 48)\nprint relativeToMidi([-12 -9 -5 0 4 7 2 5 9] 'c4')\n\n// Convert relative semitone values to frequency (A4 = 440 Hz) (alias: rtof)\n// specify the octave as second argument (default = 'C4' = 4 => 48)\nprint relativeToFreq([-12 -9 -5 0 4 7 2 5 9] 'c4')\n\n// Convert a chroma value to a relative note number (alias: ctor)\n// Can also include octave offsets with -/+, case-insensitive\nprint chromaToRelative(['C' 'Eb' 'G' 'Ab' 'A+' 'F-'])\n\n// Convert ratios to relative midi-cents (alias: rtoc)\nprint ratioToCent([2/1 3/2 4/3 5/4 9/8])",
  "442-translate-time": "// === TUTORIAL 442: Translate Time ===\n// With the methods below you can translate between various time formats\n// such as milliseconds, divisions and ratios. By default the global tempo\n// is used, but you can set a specific tempo with an additional argument\n// divisionToMs(list tempo)\n\nset tempo 120\n// convert beat division strings to milliseconds with global bpm (alias: dtom)\nprint divisionToMs([1/4 1/8 3/16 1/4 1/6 2])\n\n// use a local bpm argument\nprint divisionToMs([1/4 1/8 3/16 1/4 1/6 2] 100)\n\n// also converts ratios from floating point\nprint divisionToMs([0.25 0.125 0.1875 0.25 0.1667 2] 100)\n\n// convert beat division strings to beat ratio floats (alias: dtor)\nprint divisionToRatio([1/4 1/8 3/16 1/4 1/6 2])",
  "500-external-connections": "// === TUTORIAL 500: External Connections ===\n// It is possible to extend Mercury with external software,\n// hardware, and other tools via MIDI, OSC and Microphone inputs\n// In this chapter we'll go over these different possibilities\n// step-by-step ",
  "501-midi-note": "// === TUTORIAL 501: MIDI Note ===\n// We can also output MIDI notes from the browser to external\n// instruments or applications on the computer via WebMidi.\n// This allows us to use Mecruy for generative music while\n// other applications are handling the sound\n\nnew midi default time(1/8) note([0 3 7] 2) gain(0.8)\n// this will send a midi-note to the default device\n// a gain of 1 is a velocity of 127, 0.8 = 101",
  "502-midi-duration": "// === TUTORIAL 502: MIDI Duration ===\n// With the length() method we can change the duration.\n// The duration of a midi-note is determined by the interval between \n// the note-on and note-off message in milliseconds\n\nnew midi default time(1/8) note(0 2) length([50 100 150 200])\n// the list in length() will send different durations\n",
  "503-midi-channel": "// === TUTORIAL 503: MIDI Channel ===\n// We can change the midi-channel with the out() method\n\nnew midi default time(1/8) note(0 0) out(10)\n// channel 10 is the default drum channel in general midi\n",
  "504-midi-chord": "// === TUTORIAL 504: MIDI Chord ===\n// By setting the chord() method to 'on' we can output\n// multiple notes at the same time to create a chord\n\nnew midi default time(1) note([[0 3 7 11]] 2) chord(on)\n// here the chord is created by making a list on the first\n// place within another list (otherwise the notes would be \n// played in order over time)",
  "505-midi-control": "// === TUTORIAL 505: MIDI Control Change ===\n// With the cc() method we can send control change messages\n// to the same device, to control other parameters\n// Add multiple cc() methods to make different messages\n\nnew midi default time(1/16) note(0 0) name(myMidi)\n\tset myMidi cc(10 [50 100]) cc(20 random(4 0 127))\n// Above are two cc() methods, one to control number 10, and \n// one to 20, both with different values to change. ",
  "506-midi-pitchbend": "// === TUTORIAL 506: MIDI Pitchbend ===\n// With the bend() method you can send pitchbend messages\n// to the same device. You can only send one pitchbend message \n// at a time per channel.\n// The pitchbend range is -1.0 to 1.0, where 0 is no pitchbend\n// The output is hiresolution 14bit 0-16383\n\nset tempo 130\n\nlist pitchbender spreadF(16 -0.3 0.3)\nnew midi default time(1/16) note(0 2) bend(pitchbender)\n\n// Above is one bend() output, with 16 values ramping from\n// -0.3 to 0.3, send every 16th note.",
  "507-midi-program-change": "// === TUTORIAL 507: MIDI Program Change ===\n// With the program() method you can send program change messages\n// to the same device on the specified channel. \n// The program change is an whole number between 0 and 127.\n// The changes can be sequenced as a list.\n\nset tempo 130\n\nlist notes spread(5 0 12)\nlist changes [0 10 20]\n\nnew midi default time(1/8) note(notes 1) out(1) program(changes)\n// change program changes 0, 10 and 20 to channel 1",
  "510-input-microphone": "// === TUTORIAL 701: Input Microphone ===\n// You can access the default microphone as input in the code\n\n// WATCH OUT when not using headphones! \n// You can get very loud feedback if the output of the speakers \n// goes directly back into the microphone\n\nnew input default gain(0)\n// the gain is set at 0 to make sure there is no feedback\n// carefully increment the gain so you can hear the microphone\n\n// if your microphone is not the default then try:\n// in1, in2, in3, etc... (default = in0)",
  "511-input-functions": "// === TUTORIAL 702: Input Functions ===\n// Similar to the sample and synth you can use functions \n// to adjust the incoming sound in real time\n// For example this is a stutter effect where the sound\n// is only let through when the envelope is triggered\n\nset tempo 120\n\nnew input default shape(1 1/32 1) time(1/16) gain(1)",
  "512-input-fx": "// === TUTORIAL 703: Input FX ===\n// It is also possible to add FX to the incoming microphone sound\n// Such as distortion, delay, pitchshifting, filtering, etc...\n\nset tempo 100\n\nnew input default name(mic)\n    set mic time(1/16) shape(1 1/32 1) gain(1)\n    set mic fx(shift -12) fx(degrade 0.5) fx(delay 2/16 3/16 0.9)",
  "520-open-sound-control": "// === TUTORIAL 520: Open Sound Control (OSC) ===\n// It is possible to send OSC Messages to Mercury instruments. \n// However this is only possible when running Mercury via a localhost. \n// Go to https://github.com/tmhglnd/mercury-playground#-install \n// and follow the instructions to run mercury locally.\n\n// Now send osc-messages from other applications to \n// ip: 127.0.0.1 (or localhost) at port: 8000\n\n// for example control the note, length, volume and filter of a sawtooth synth\n// the osc-addresses are written as strings ''\nset tempo 100\nnew synth saw name(syn0) time(1/16)\n\tset syn0 note('/synth/note') shape(1 '/synth/length') gain('/synth/vol')\n\tset syn0 fx(filter low '/synth/cutoff' 0.5)",
  "521-osc-output": "// === TUTORIAL 521: OSC Output ===\n// With the new osc instrument you can send osc messages at addresses \n// at a specific time interval/rhythm. The functions you type are used\n// as osc addresses. The name of the instrument is the base of the address\n//\n// This instrument only works when running Mercury via a localhost. \n// Follow instructions: https://github.com/tmhglnd/mercury-playground#-install \n\n// Receive OSC messages at port 2440\n\nset tempo 100\nnew osc base name(send) time(1/16)\n\tset send play(euclid(16 11)) // send messages rhythmically\n\tset send trigger(1) msg(spread(5 0 12)) // arguments can be lists\n\n// expected messages received at port 2440:\n// /base/trigger 1\n// /base/msg 4\n// /base/trigger 1\n// /base/msg 7\n// ...\n\n// some function words are not allowed to be used as osc address \n// because they are used for the core functionality of the instrument:\n// time, play, timediv, name",
  "601-hydra-visuals": "// === TUTORIAL 601: Hydra Visuals ===\n// We can store hydra sketches as a string in a list\n// By creating a list of multiple sketches the instrument\n// will cycle through them for every trigger\n\nlist hydras ['osc(10,0.1,2).out()' 'osc(20,-0.5,5).out()' 'osc(5,1,12).out()']\n\nnew sample kick_min time(1/16) play([1 0 0 1 0]) visual(hydras)",
  "602-view-list": "// === TUTORIAL 602: View List ===\n// It is possible to view the content of a list in a\n// visual manner. By using 'view' the list will be \n// normalized (0-1) and displayed as grayscale values\n// across the screen. The length of the list will\n// determine the amount of squares displayed\n\nlist myVals mod(repeat(palin(spreadF(46 1 0)) 3) 0.15)\n\nview myVals\n",
  "603-view-list-rgb": "// === TUTORIAL 603: View List RGB ===\n// If you merge() three lists you can display Red,\n// Green and Blue values seperately. Make sure the lists\n// have the same length in order to fill all pixels equally\n// All lists are normalized together, so if one list has very large\n// numbers, the other lists will become very dark\n\nlist cos mod(cosine(3034 50 0 7) 3)\nlist sin mod(sine(3034 40 0 7) 3)\nlist cos2 mod(cosine(3034 20 0 20) 3)\n\nview merge(cos sin cos2)",
  "604-view-with-hydra": "// === TUTORIAL 604: View & Hydra ===\n// You can access the canvas of the displayed list by\n// initializing a hydra source: s0.init({src: listView})\n\nlist cos mod(cosine(2000 60 20) 2)\nview cos\n\nlist hydraVisual ['s0.init({src: listView}); src(s0).modulate(noise([2,5,10]), [0.05, 0.1]).out()']\nnew sample hat_909 time(1/4) visual(hydraVisual)\n",
  "700-samples-freesound": "// === TUTORIAL 700: Samples Freesound ===\n// It is possible to load soundfiles via links from freesound\n// by create a list for every sample you can specify the sound name and the url\n\nlist s1 [ snare_short 'https://cdn.freesound.org/previews/671/671221_3797507-lq.mp3' ]\nlist s2 [ psykick 'https://cdn.freesound.org/previews/145/145778_2101444-lq.mp3' ]\nlist s3 [ hat_short 'https://cdn.freesound.org/previews/222/222058_1676145-lq.mp3' ]\n// load the samples with 'set samples'. This function only needs to be \n// evaluated once! afterwards you can comment it.\nset samples s1 s2 s3\n\n// The sounds can be used with the name specified in the list\n// Loading the samples takes some time so better first load the sounds and \n// then uncomment this code so you can use it and listen\n// new sample psykick time(1/4)\n// new sample snare_short time(1/16) play(euclid(7 3)) gain(0.5)\n// new sample hat_short time(1/4 1/8) gain(1.3)",
  "701-samples-github": "// === TUTORIAL 701: Samples Github ===\n// Loading samples from a github raw file is also possible\n// If you know the location of the file you can change the url by starting\n// with: https://raw.githubusercontent.com/ followed by the user/repo/branch/path\n\n// comment this line when the sound is loaded\nset samples [ housekick 'https://raw.githubusercontent.com/tmhglnd/mercury/master/mercury_ide/media/samples/drums/kick/kick_house.wav' ]\n\n// uncomment this line after loading the sounds\n// new sample housekick time(1/4)",
  "702-samples-json": "// === TUTORIAL 702: Samples JSON ===\n// Loading more than one sample is also possible via a .json file\n// The .json file can be stored on the computer and selected \n// when click 'add sounds'. Or it can be stored on github and used \n// via the raw file link as argument to 'set samples'\n\n// A .json file could look like this:\n// {\n// \t\"snare_short\" : \"https://cdn.freesound.org/previews/671/671221_3797507-lq.mp3\",\n// \t\"psykick\" : \"https://cdn.freesound.org/previews/145/145778_2101444-lq.mp3\",\n// \t\"hat_short\" : \"https://cdn.freesound.org/previews/222/222058_1676145-lq.mp3\"\n// }\n\n// If the base url is the same for all the sounds you can add that \n// as a separate key:value in the dictionairy\n\n// {\n// \t\"snare_short\" : \"671/671221_3797507-lq.mp3\",\n// \t\"psykick\" : \"145/145778_2101444-lq.mp3\",\n// \t\"hat_short\" : \"222/222058_1676145-lq.mp3\",\n// \t\"_base\" : \"https://cdn.freesound.org/previews/\"\n// }",
  "800-advanced": "// === TUTORIAL 800: Advanced Techniques ===\n// This chapter demonstrates various advanced sound and\n// composition techniques that can be achieved with the \n// Mercury language.\n\n// You will find topics such as:\n// Granular Synthesis, \n// (more to do..., suggestions welcome on github issues)",
  "801-granulation": "// === TUTORIAL 801: Granulation Basic ===\n// Simple granular timestretching is achieved\n// by quickly playing short grains of a sample\n// changing the offset of the playback point \n// and detuning the grains\nset tempo 120\n\n// a position ramp up-down over 500 values\nlist pos sineFloat(500 1 0 0.5)\n\n// small detuning for every sample playback\nlist detune randomFloat(500 0.92 1.08)\n\n// try different sample names\nnew sample bongo name(grain)\n    // a fast time interval and a short attack and release time for fade-in/out\n    set grain time(1/32) shape(20 20)\n    // set the start position from the list and random panning\n    set grain start(pos) pan(random)\n    // set the playback speed and gain\n    set grain speed(detune) gain(1.2)\n    // add some effects\n    set grain fx(delay 2/32 3/32 0.9) fx(reverb 0.4 5)"
}
